root = item* ;

item = binding ;

binding = 'let' NAME typeAnn? '=' expr ;

expr = '(' ')'                 (* Unit *)
     | NUMBER                  (* Int *)
     | 'true' | 'false'        (* Bool *)
     | STRING                  (* String *)
     | NAME                    (* Variable *)
     | let                     (* Let binding *)
     | lambda                  (* Lambda *)
     | if                      (* If-else *)
     | expr expr               (* Application
                                  Does not permit trailing let bindings, lambdas,
                                  or if expressions without parens. *)
     | '(' expr ')'            (* Syntactic grouping *)
     | '(' expr typeAnn ')'    (* Type annotation *)
     ;

let = 'let' pattern '=' expr 'in' expr ;

if = 'if' expr 'then' expr 'else' expr ;

lambda = 'fun' '|'? case ('|' case)* ;

case = pattern '->' expr ;

pattern = '_'                     (* Wildcard *)
        | NAME                    (* Wildcard variable *)
        | '(' ')'                 (* Unit *)
        | NUMBER                  (* Int *)
        | 'true' | 'false'        (* Bool *)
        | '(' pattern ')'         (* Syntactic grouping *)
        | pattern typeAnn         (* Type annotation *)
        ;

typeAnn = ':' type ;

type = '(' ')'                         (* Unit *)
     | 'Int'                           (* Int *)
     | 'Bool'                          (* Bool *)
     | 'String'                        (* String *)
     | TYPE_VAR                        (* Type variable *)
     | type '->' type                  (* Function *)
     | 'forall' TYPE_VAR* '.' type     (* Quantifier *)
     | '(' type ')'                    (* Syntactic grouping *)
     ;
